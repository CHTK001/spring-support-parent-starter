# 支付模块状态机改造说明

## 一、改造概述

本次改造将支付模块的订单状态流转管理从传统的直接状态修改方式升级为基于 **Spring State Machine** 的状态机管理方式。

### 改造目标

1. **统一状态管理**：所有订单状态转换通过状态机统一管理，避免状态流转逻辑分散
2. **状态转换合法性校验**：状态机自动校验状态转换是否合法，防止非法状态流转
3. **状态持久化**：支持状态机状态持久化到Redis，支持分布式环境
4. **可追溯性**：完整的状态转换日志记录，便于问题追踪和审计
5. **可扩展性**：便于后续添加新的状态和转换规则

## 二、核心组件

### 1. PayOrderEvent（订单状态机事件枚举）

定义了触发状态转换的所有事件：

| 事件 | 说明 | 适用场景 |
|------|------|----------|
| CREATE | 创建订单 | 订单初始化 |
| CREATE_FAILED | 创建失败 | 订单创建异常 |
| WAIT_PAY | 等待支付 | 订单创建成功后等待支付 |
| START_PAY | 开始支付 | 用户发起支付操作 |
| PAY_SUCCESS | 支付成功 | 支付完成 |
| TIMEOUT | 订单超时 | 超过支付时限 |
| CANCEL | 取消订单 | 用户主动取消 |
| CLOSE | 关闭订单 | 系统或用户关闭订单 |
| REFUND | 申请退款 | 发起退款请求 |
| REFUND_SUCCESS | 退款成功 | 退款完成 |
| REFUND_PART_SUCCESS | 部分退款 | 部分金额退款成功 |

### 2. PayOrderStateMachineConfig（状态机配置类）

配置订单状态流转规则，定义了以下状态转换关系：

#### 2.1 正常支付流程

```
创建(PAY_CREATE) 
    -> 待支付(PAY_WAITING) 
    -> 支付中(PAY_PAYING) 
    -> 支付成功(PAY_SUCCESS)
```

或快速支付流程（如钱包支付）：

```
创建(PAY_CREATE) 
    -> 待支付(PAY_WAITING) 
    -> 支付成功(PAY_SUCCESS)
```

#### 2.2 订单超时流程

```
创建(PAY_CREATE) -> 超时(PAY_TIMEOUT)
待支付(PAY_WAITING) -> 超时(PAY_TIMEOUT)
```

#### 2.3 订单取消流程

```
创建(PAY_CREATE) -> 取消(PAY_CANCEL_SUCCESS)
待支付(PAY_WAITING) -> 取消(PAY_CANCEL_SUCCESS)
```

#### 2.4 订单关闭流程

```
创建(PAY_CREATE) -> 关闭(PAY_CLOSE_SUCCESS)
待支付(PAY_WAITING) -> 关闭(PAY_CLOSE_SUCCESS)
支付中(PAY_PAYING) -> 关闭(PAY_CLOSE_SUCCESS)
```

#### 2.5 退款流程

完整退款：
```
支付成功(PAY_SUCCESS) 
    -> 正在退款(PAY_REFUND_WAITING) 
    -> 退款成功(PAY_REFUND_SUCCESS)
```

部分退款：
```
支付成功(PAY_SUCCESS) 
    -> 正在退款(PAY_REFUND_WAITING) 
    -> 部分退款(PAY_REFUND_PART_SUCCESS) 
    -> 正在退款(PAY_REFUND_WAITING) 
    -> 退款成功(PAY_REFUND_SUCCESS)
```

### 3. PayOrderStateMachineService（状态机服务）

提供订单状态流转的核心服务方法：

#### 3.1 sendEvent（发送状态转换事件）

```java
/**
 * 发送状态转换事件（同步）
 *
 * @param orderCode 订单编号
 * @param currentStatus 当前状态
 * @param event 状态转换事件
 * @param order 订单实体
 * @return 是否转换成功
 */
boolean sendEvent(String orderCode, PayOrderStatus currentStatus, 
                  PayOrderEvent event, PayMerchantOrder order)
```

**使用示例**：

```java
// 订单从待支付转为支付成功
boolean success = stateMachineService.sendEvent(
    order.getPayMerchantOrderCode(),
    PayOrderStatus.PAY_WAITING,
    PayOrderEvent.PAY_SUCCESS,
    order
);

if (success) {
    // 状态转换成功，更新数据库
    order.setPayMerchantOrderStatus(PayOrderStatus.PAY_SUCCESS);
    orderService.updateById(order);
}
```

#### 3.2 canSendEvent（检查状态转换是否合法）

```java
/**
 * 检查状态转换是否合法
 *
 * @param orderCode 订单编号
 * @param currentStatus 当前状态
 * @param event 状态转换事件
 * @return 是否合法
 */
boolean canSendEvent(String orderCode, PayOrderStatus currentStatus, 
                     PayOrderEvent event)
```

**使用示例**：

```java
// 检查是否可以关闭订单
if (stateMachineService.canSendEvent(orderCode, currentStatus, PayOrderEvent.CLOSE)) {
    // 可以关闭，执行关闭逻辑
} else {
    // 不能关闭，返回错误信息
    return ReturnResult.illegal("当前状态不允许关闭订单");
}
```

### 4. PayOrderStateChangeListener（状态转换监听器）

监听状态转换过程，记录详细的状态流转日志，包括：

- 状态转换开始
- 状态转换完成
- 状态改变
- 状态进入/退出
- 事件未接受（非法转换）
- 状态机启动/停止
- 状态机错误

### 5. PayOrderStateMachinePersistConfig（状态机持久化配置）

使用Redis持久化状态机状态，支持：

- 状态机状态持久化
- 状态机状态恢复
- 分布式环境下的状态共享

**Redis存储键格式**：`pay:statemachine:order:{订单编号}`

## 三、改造内容

### 1. PayMerchantOrderServiceImpl 改造

#### 1.1 createSign（创建签名）

**改造前**：
```java
merchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_WAITING);
this.updateById(merchantOrder);
```

**改造后**：
```java
// 使用状态机转换状态：创建 -> 待支付
boolean stateChanged = stateMachineService.sendEvent(
    merchantOrder.getPayMerchantOrderCode(),
    merchantOrder.getPayMerchantOrderStatus(),
    PayOrderEvent.WAIT_PAY,
    merchantOrder
);

if (stateChanged) {
    merchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_WAITING);
    this.updateById(merchantOrder);
}
```

#### 1.2 finishWechatOrder（完成微信支付）

**改造前**：
```java
payMerchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_SUCCESS);
this.updateById(payMerchantOrder);
```

**改造后**：
```java
// 使用状态机转换状态：待支付/支付中 -> 支付成功
boolean stateChanged = stateMachineService.sendEvent(
    payMerchantOrder.getPayMerchantOrderCode(),
    currentStatus,
    PayOrderEvent.PAY_SUCCESS,
    payMerchantOrder
);

if (stateChanged) {
    payMerchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_SUCCESS);
    this.updateById(payMerchantOrder);
}
```

#### 1.3 refundOrder（退款订单）

**改造前**：
```java
this.updateById(payMerchantOrder);
```

**改造后**：
```java
// 根据目标状态选择事件
PayOrderEvent event;
if (targetStatus == PayOrderStatus.PAY_REFUND_SUCCESS) {
    event = PayOrderEvent.REFUND_SUCCESS;
} else if (targetStatus == PayOrderStatus.PAY_REFUND_PART_SUCCESS) {
    event = PayOrderEvent.REFUND_PART_SUCCESS;
} else if (targetStatus == PayOrderStatus.PAY_REFUND_WAITING) {
    event = PayOrderEvent.REFUND;
}

// 使用状态机转换状态
boolean stateChanged = stateMachineService.sendEvent(
    payMerchantOrder.getPayMerchantOrderCode(),
    currentStatus,
    event,
    payMerchantOrder
);

if (stateChanged) {
    this.updateById(payMerchantOrder);
}
```

#### 1.4 timeout（订单超时）

**改造前**：
```java
baseMapper.update(
    Wrappers.<PayMerchantOrder>lambdaUpdate()
        .eq(PayMerchantOrder::getPayMerchantId, payMerchantId)
        .in(PayMerchantOrder::getPayMerchantOrderStatus, 
            PayOrderStatus.PAY_WAITING, PayOrderStatus.PAY_CREATE)
        .set(PayMerchantOrder::getPayMerchantOrderStatus, PayOrderStatus.PAY_TIMEOUT)
);
```

**改造后**：
```java
// 查询超时的订单
List<PayMerchantOrder> timeoutOrders = this.list(...);

// 使用状态机逐个处理超时订单
for (PayMerchantOrder order : timeoutOrders) {
    boolean stateChanged = stateMachineService.sendEvent(
        order.getPayMerchantOrderCode(),
        order.getPayMerchantOrderStatus(),
        PayOrderEvent.TIMEOUT,
        order
    );
    
    if (stateChanged) {
        order.setPayMerchantOrderStatus(PayOrderStatus.PAY_TIMEOUT);
        this.updateById(order);
    }
}
```

#### 1.5 closeOrder（关闭订单）

**改造前**：
```java
baseMapper.update(
    Wrappers.<PayMerchantOrder>lambdaUpdate()
        .eq(PayMerchantOrder::getPayMerchantOrderCode, payMerchantOrderCode)
        .set(PayMerchantOrder::getPayMerchantOrderStatus, PayOrderStatus.PAY_CLOSE_SUCCESS)
);
```

**改造后**：
```java
// 使用状态机转换状态
boolean stateChanged = stateMachineService.sendEvent(
    payMerchantOrderCode,
    payMerchantOrderStatus,
    PayOrderEvent.CLOSE,
    merchantOrder
);

if (stateChanged) {
    merchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_CLOSE_SUCCESS);
    this.baseMapper.updateById(merchantOrder);
}
```

## 四、优势分析

### 1. 代码质量提升

- **逻辑集中**：状态流转规则集中在配置类中，易于理解和维护
- **类型安全**：编译期检查状态和事件的合法性
- **代码简洁**：业务代码只需调用状态机服务，无需关心状态流转细节

### 2. 安全性增强

- **自动校验**：状态机自动校验状态转换是否合法，防止非法状态流转
- **原子性**：状态转换和持久化在同一个事务中，保证数据一致性
- **审计日志**：完整的状态转换日志，便于问题追踪和审计

### 3. 可维护性提升

- **规则清晰**：状态流转规则一目了然，便于新人理解
- **易于扩展**：添加新状态或转换规则只需修改配置类
- **测试友好**：状态机逻辑独立，便于编写单元测试

### 4. 分布式支持

- **状态持久化**：使用Redis持久化状态机状态
- **状态恢复**：支持从Redis恢复状态机状态
- **分布式共享**：多个实例可以共享状态机状态

## 五、使用示例

### 1. 订单支付成功

```java
@Service
public class WechatPayCallbackService {
    
    @Autowired
    private PayOrderStateMachineService stateMachineService;
    
    @Autowired
    private PayMerchantOrderService orderService;
    
    public void handlePaySuccess(String orderCode) {
        // 查询订单
        PayMerchantOrder order = orderService.getByCode(orderCode);
        
        // 使用状态机转换状态
        boolean success = stateMachineService.sendEvent(
            orderCode,
            order.getPayMerchantOrderStatus(),
            PayOrderEvent.PAY_SUCCESS,
            order
        );
        
        if (success) {
            // 更新订单状态
            order.setPayMerchantOrderStatus(PayOrderStatus.PAY_SUCCESS);
            order.setPayMerchantOrderPayTime(LocalDateTime.now());
            orderService.updateById(order);
            
            // 发布支付成功事件
            applicationContext.publishEvent(new FinishPayOrderEvent(orderCode));
        }
    }
}
```

### 2. 订单退款

```java
@Service
public class RefundService {
    
    @Autowired
    private PayOrderStateMachineService stateMachineService;
    
    @Autowired
    private PayMerchantOrderService orderService;
    
    public ReturnResult<Void> refundOrder(String orderCode, BigDecimal amount) {
        // 查询订单
        PayMerchantOrder order = orderService.getByCode(orderCode);
        
        // 检查是否可以退款
        if (!stateMachineService.canSendEvent(
                orderCode, 
                order.getPayMerchantOrderStatus(), 
                PayOrderEvent.REFUND)) {
            return ReturnResult.illegal("当前订单状态不允许退款");
        }
        
        // 使用状态机转换状态
        boolean success = stateMachineService.sendEvent(
            orderCode,
            order.getPayMerchantOrderStatus(),
            PayOrderEvent.REFUND,
            order
        );
        
        if (success) {
            // 更新订单状态
            order.setPayMerchantOrderStatus(PayOrderStatus.PAY_REFUND_WAITING);
            orderService.updateById(order);
            
            // 调用退款接口
            // ...
        }
        
        return ReturnResult.ok();
    }
}
```

## 六、测试用例

项目包含完整的状态机测试用例（`PayOrderStateMachineTest`），覆盖以下场景：

1. 正常支付流程测试
2. 快速支付流程测试
3. 订单超时流程测试
4. 订单关闭流程测试
5. 订单取消流程测试
6. 完整退款流程测试
7. 部分退款流程测试
8. 非法状态转换测试
9. 状态转换合法性检查测试

运行测试：

```bash
mvn test -Dtest=PayOrderStateMachineTest
```

## 七、注意事项

### 1. 数据一致性

状态机状态转换成功后，必须同步更新数据库中的订单状态，建议在事务中完成：

```java
transactionTemplate.execute(status -> {
    boolean success = stateMachineService.sendEvent(...);
    if (success) {
        orderService.updateById(order);
    }
    return success;
});
```

### 2. Redis依赖

状态机持久化依赖Redis，确保Redis服务正常运行。如果Redis不可用，状态机仍可工作，但状态不会被持久化。

### 3. 日志监控

状态机监听器会记录详细的状态转换日志，建议配置日志级别为INFO或DEBUG，便于问题排查：

```yaml
logging:
  level:
    com.chua.starter.pay.support.statemachine: DEBUG
```

### 4. 性能考虑

每次状态转换都会创建和销毁状态机实例，对于高并发场景，建议：

- 使用状态机缓存池
- 异步处理状态转换
- 批量处理超时订单

### 5. 扩展建议

如需添加新的状态或转换规则：

1. 在 `PayOrderStatus` 枚举中添加新状态
2. 在 `PayOrderEvent` 枚举中添加新事件
3. 在 `PayOrderStateMachineConfig` 中配置新的转换关系
4. 在业务代码中调用状态机服务

## 八、总结

本次状态机改造极大提升了支付模块的代码质量和可维护性。通过引入Spring State Machine，实现了：

1. ✅ 状态流转规则集中管理
2. ✅ 状态转换合法性自动校验
3. ✅ 完整的状态转换日志记录
4. ✅ 支持分布式环境的状态持久化
5. ✅ 便于扩展和维护

建议在其他需要复杂状态管理的模块（如订单、工单等）中推广使用状态机模式。

