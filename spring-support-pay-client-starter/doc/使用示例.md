# 支付模块使用示例

## 示例1：创建订单并支付（微信JSAPI）

```java
@RestController
@RequestMapping("/api/pay")
@RequiredArgsConstructor
@Slf4j
public class PaymentController {
    
    private final PayMerchantOrderService orderService;
    private final PayOrderStateMachineService stateMachineService;
    
    /**
     * 创建微信JSAPI支付订单
     */
    @PostMapping("/create")
    public ReturnResult<CreateOrderV2Response> createOrder(@RequestBody CreateOrderRequest request) {
        // 1. 构建创建订单请求
        CreateOrderV2Request orderRequest = new CreateOrderV2Request();
        orderRequest.setPayMerchantId(1);
        orderRequest.setPayTradeType(PayTradeType.PAY_WECHAT_JSAPI);
        orderRequest.setPayMerchantOrderAmount(request.getAmount());
        orderRequest.setPayMerchantOrderOriginId(request.getProductId());
        orderRequest.setPayMerchantOrderRemark(request.getRemark());
        
        // 2. 创建订单
        ReturnResult<CreateOrderV2Response> result = orderService.createOrder(orderRequest);
        
        if (result.isSuccess()) {
            log.info("订单创建成功: {}", result.getData().getPayMerchantOrderCode());
        }
        
        return result;
    }
    
    /**
     * 创建支付签名（用于前端调起支付）
     */
    @PostMapping("/sign")
    public ReturnResult<PaySignResponse> createSign(@RequestBody CreateSignRequest request) {
        // 1. 查询订单
        PayMerchantOrder order = orderService.getByCode(request.getOrderCode());
        if (order == null) {
            return ReturnResult.illegal("订单不存在");
        }
        
        // 2. 检查订单状态
        if (order.getPayMerchantOrderStatus() != PayOrderStatus.PAY_CREATE) {
            return ReturnResult.illegal("订单状态不正确");
        }
        
        // 3. 创建支付签名（内部会使用状态机转换状态）
        CreateOrderV2Response response = new CreateOrderV2Response();
        response.setPayMerchantOrderCode(request.getOrderCode());
        response.setPrepayId(request.getPrepayId());
        
        return orderService.createSign(response);
    }
}
```

## 示例2：处理微信支付回调

```java
@RestController
@RequestMapping("/api/pay/callback")
@RequiredArgsConstructor
@Slf4j
public class PayCallbackController {
    
    private final PayMerchantOrderService orderService;
    private final PayOrderStateMachineService stateMachineService;
    private final ApplicationContext applicationContext;
    
    /**
     * 处理微信支付成功回调
     */
    @PostMapping("/wechat/success")
    public WechatOrderCallbackResponse handleWechatPaySuccess(@RequestBody WechatOrderCallbackRequest request) {
        try {
            // 1. 解密回调数据
            String orderCode = request.getOutTradeNo();
            String transactionId = request.getTransactionId();
            
            log.info("收到微信支付回调: orderCode={}, transactionId={}", orderCode, transactionId);
            
            // 2. 查询订单
            PayMerchantOrder order = orderService.getByCode(orderCode);
            if (order == null) {
                log.error("订单不存在: {}", orderCode);
                return WechatOrderCallbackResponse.fail("订单不存在");
            }
            
            // 3. 检查订单状态
            if (order.getPayMerchantOrderStatus() == PayOrderStatus.PAY_SUCCESS) {
                log.warn("订单已支付: {}", orderCode);
                return WechatOrderCallbackResponse.success();
            }
            
            // 4. 更新订单信息
            order.setPayMerchantOrderTransactionId(transactionId);
            
            // 5. 使用状态机完成订单（内部会转换状态并发布事件）
            boolean success = orderService.finishWechatOrder(order);
            
            if (success) {
                log.info("订单支付成功: {}", orderCode);
                return WechatOrderCallbackResponse.success();
            } else {
                log.error("订单状态转换失败: {}", orderCode);
                return WechatOrderCallbackResponse.fail("订单处理失败");
            }
            
        } catch (Exception e) {
            log.error("处理微信支付回调失败", e);
            return WechatOrderCallbackResponse.fail("处理失败");
        }
    }
}
```

## 示例3：订单退款

```java
@RestController
@RequestMapping("/api/refund")
@RequiredArgsConstructor
@Slf4j
public class RefundController {
    
    private final PayMerchantOrderService orderService;
    private final PayOrderStateMachineService stateMachineService;
    
    /**
     * 申请订单退款
     */
    @PostMapping("/apply")
    public ReturnResult<RefundOrderV2Response> applyRefund(@RequestBody RefundRequest request) {
        // 1. 查询订单
        PayMerchantOrder order = orderService.getByCode(request.getOrderCode());
        if (order == null) {
            return ReturnResult.illegal("订单不存在");
        }
        
        // 2. 检查订单状态是否可以退款
        if (!stateMachineService.canSendEvent(
                request.getOrderCode(),
                order.getPayMerchantOrderStatus(),
                PayOrderEvent.REFUND)) {
            return ReturnResult.illegal("订单当前状态不允许退款");
        }
        
        // 3. 构建退款请求
        RefundOrderV2Request refundRequest = new RefundOrderV2Request();
        refundRequest.setRefundAmount(request.getRefundAmount());
        refundRequest.setRefundReason(request.getRefundReason());
        
        // 4. 执行退款（内部会使用状态机转换状态）
        ReturnResult<RefundOrderV2Response> result = orderService.refundOrder(
                request.getOrderCode(), 
                refundRequest
        );
        
        if (result.isSuccess()) {
            log.info("退款申请成功: orderCode={}, amount={}", 
                    request.getOrderCode(), 
                    request.getRefundAmount());
        }
        
        return result;
    }
    
    /**
     * 退款到钱包
     */
    @PostMapping("/wallet")
    public ReturnResult<RefundOrderV2Response> refundToWallet(@RequestBody RefundRequest request) {
        // 1. 查询订单
        PayMerchantOrder order = orderService.getByCode(request.getOrderCode());
        if (order == null) {
            return ReturnResult.illegal("订单不存在");
        }
        
        // 2. 构建退款请求
        RefundOrderV2Request refundRequest = new RefundOrderV2Request();
        refundRequest.setRefundAmount(request.getRefundAmount());
        refundRequest.setRefundReason(request.getRefundReason());
        
        // 3. 退款到钱包
        return orderService.refundOrderToWallet(request.getOrderCode(), refundRequest);
    }
}
```

## 示例4：订单状态查询和关闭

```java
@RestController
@RequestMapping("/api/order")
@RequiredArgsConstructor
@Slf4j
public class OrderController {
    
    private final PayMerchantOrderService orderService;
    private final PayOrderStateMachineService stateMachineService;
    
    /**
     * 查询订单状态
     */
    @GetMapping("/status/{orderCode}")
    public ReturnResult<OrderStatusResponse> getOrderStatus(@PathVariable String orderCode) {
        // 查询订单状态（带缓存）
        PayOrderStatus status = orderService.getOrderStatus(orderCode);
        
        OrderStatusResponse response = new OrderStatusResponse();
        response.setOrderCode(orderCode);
        response.setStatus(status);
        response.setStatusName(status.getName());
        
        return ReturnResult.ok(response);
    }
    
    /**
     * 关闭订单
     */
    @PostMapping("/close/{orderCode}")
    public ReturnResult<Boolean> closeOrder(@PathVariable String orderCode) {
        // 1. 查询订单
        PayMerchantOrder order = orderService.getByCode(orderCode);
        if (order == null) {
            return ReturnResult.illegal("订单不存在");
        }
        
        // 2. 检查是否可以关闭
        PayOrderStatus currentStatus = order.getPayMerchantOrderStatus();
        if (!stateMachineService.canSendEvent(orderCode, currentStatus, PayOrderEvent.CLOSE)) {
            return ReturnResult.illegal("订单当前状态不允许关闭");
        }
        
        // 3. 关闭订单（内部会使用状态机转换状态）
        return orderService.closeOrder(orderCode);
    }
    
    /**
     * 批量查询订单
     */
    @PostMapping("/list")
    public ReturnResult<IPage<PayMerchantOrderVO>> listOrders(@RequestBody OrderQueryRequest request) {
        Query<PayMerchantOrder> query = new Query<>();
        query.setCurrent(request.getPageNum());
        query.setSize(request.getPageSize());
        
        PayMerchantOrder condition = new PayMerchantOrder();
        condition.setUserId(RequestUtils.getUserId());
        
        PayMerchantOrderPageRequest pageRequest = new PayMerchantOrderPageRequest();
        pageRequest.setStartTime(request.getStartTime());
        pageRequest.setEndTime(request.getEndTime());
        
        IPage<PayMerchantOrderVO> page = orderService.pageForPayMerchantOrder(query, condition, pageRequest);
        
        return ReturnResult.ok(page);
    }
}
```

## 示例5：监听订单事件

```java
@Component
@Slf4j
@RequiredArgsConstructor
public class PayOrderEventListener {
    
    private final NotificationService notificationService;
    private final InventoryService inventoryService;
    private final PointsService pointsService;
    
    /**
     * 监听订单支付成功事件
     */
    @EventListener
    @Async
    public void onPaySuccess(FinishPayOrderEvent event) {
        PayMerchantOrder order = event.getPayMerchantOrder();
        String orderCode = order.getPayMerchantOrderCode();
        
        log.info("订单支付成功事件: {}", orderCode);
        
        try {
            // 1. 发送支付成功通知
            notificationService.sendPaySuccessNotification(
                    order.getUserId(),
                    orderCode,
                    order.getPayMerchantOrderAmount()
            );
            
            // 2. 扣减库存
            inventoryService.decreaseStock(
                    order.getPayMerchantOrderOriginId(),
                    1
            );
            
            // 3. 增加积分
            pointsService.addPoints(
                    order.getUserId(),
                    order.getPayMerchantOrderAmount().intValue()
            );
            
            log.info("订单支付成功事件处理完成: {}", orderCode);
            
        } catch (Exception e) {
            log.error("处理订单支付成功事件失败: {}", orderCode, e);
        }
    }
    
    /**
     * 监听订单退款成功事件
     */
    @EventListener
    @Async
    public void onRefundSuccess(RefundPayOrderEvent event) {
        PayMerchantOrder order = event.getPayMerchantOrder();
        String orderCode = order.getPayMerchantOrderCode();
        
        log.info("订单退款成功事件: {}", orderCode);
        
        try {
            // 1. 发送退款成功通知
            notificationService.sendRefundSuccessNotification(
                    order.getUserId(),
                    orderCode,
                    order.getPayMerchantOrderAmount()
            );
            
            // 2. 恢复库存
            if (order.getPayMerchantOrderStatus() == PayOrderStatus.PAY_REFUND_SUCCESS) {
                inventoryService.increaseStock(
                        order.getPayMerchantOrderOriginId(),
                        1
                );
            }
            
            // 3. 扣除积分
            pointsService.deductPoints(
                    order.getUserId(),
                    order.getPayMerchantOrderAmount().intValue()
            );
            
            log.info("订单退款成功事件处理完成: {}", orderCode);
            
        } catch (Exception e) {
            log.error("处理订单退款成功事件失败: {}", orderCode, e);
        }
    }
    
    /**
     * 监听订单关闭事件
     */
    @EventListener
    @Async
    public void onOrderClose(CloseOrderEvent event) {
        PayMerchantOrder order = event.getPayMerchantOrder();
        String orderCode = order.getPayMerchantOrderCode();
        
        log.info("订单关闭事件: {}", orderCode);
        
        try {
            // 发送订单关闭通知
            notificationService.sendOrderCloseNotification(
                    order.getUserId(),
                    orderCode
            );
            
            log.info("订单关闭事件处理完成: {}", orderCode);
            
        } catch (Exception e) {
            log.error("处理订单关闭事件失败: {}", orderCode, e);
        }
    }
}
```

## 示例6：定时任务处理超时订单

```java
@Component
@Slf4j
@RequiredArgsConstructor
public class PayOrderScheduler {
    
    private final PayMerchantOrderService orderService;
    private final PayMerchantService merchantService;
    
    /**
     * 每分钟执行一次，处理超时订单
     */
    @Scheduled(cron = "0 * * * * ?")
    public void handleTimeoutOrders() {
        log.debug("开始处理超时订单");
        
        try {
            // 查询所有商户
            List<PayMerchant> merchants = merchantService.list();
            
            int totalTimeout = 0;
            
            // 逐个商户处理超时订单
            for (PayMerchant merchant : merchants) {
                // 超时时间（分钟）
                Integer timeoutMinutes = merchant.getPayMerchantOpenTimeoutTime();
                if (timeoutMinutes == null || timeoutMinutes <= 0) {
                    continue;
                }
                
                // 处理超时订单（内部会使用状态机转换状态）
                int count = orderService.timeout(
                        merchant.getPayMerchantId(),
                        timeoutMinutes
                );
                
                if (count > 0) {
                    log.info("商户 {} 处理超时订单 {} 个", 
                            merchant.getPayMerchantName(), 
                            count);
                    totalTimeout += count;
                }
            }
            
            if (totalTimeout > 0) {
                log.info("本次处理超时订单总数: {}", totalTimeout);
            }
            
        } catch (Exception e) {
            log.error("处理超时订单失败", e);
        }
    }
}
```

## 示例7：自定义状态转换拦截器

```java
@Component
@Slf4j
public class PayOrderStateInterceptor extends StateMachineInterceptorAdapter<PayOrderStatus, PayOrderEvent> {
    
    /**
     * 状态转换前置处理
     */
    @Override
    public void preStateChange(
            State<PayOrderStatus, PayOrderEvent> state,
            Message<PayOrderEvent> message,
            Transition<PayOrderStatus, PayOrderEvent> transition,
            StateMachine<PayOrderStatus, PayOrderEvent> stateMachine,
            StateMachine<PayOrderStatus, PayOrderEvent> rootStateMachine) {
        
        PayOrderStatus targetStatus = state.getId();
        String orderCode = message.getHeaders().get(
                PayOrderStateMachineService.ORDER_CODE_HEADER, 
                String.class
        );
        
        log.info("订单状态即将转换: orderCode={}, targetStatus={}", 
                orderCode, 
                targetStatus.getName());
        
        // 可以在这里做一些前置检查
        // 例如：验证订单金额、检查库存等
    }
    
    /**
     * 状态转换后置处理
     */
    @Override
    public void postStateChange(
            State<PayOrderStatus, PayOrderEvent> state,
            Message<PayOrderEvent> message,
            Transition<PayOrderStatus, PayOrderEvent> transition,
            StateMachine<PayOrderStatus, PayOrderEvent> stateMachine,
            StateMachine<PayOrderStatus, PayOrderEvent> rootStateMachine) {
        
        PayOrderStatus targetStatus = state.getId();
        String orderCode = message.getHeaders().get(
                PayOrderStateMachineService.ORDER_CODE_HEADER, 
                String.class
        );
        
        log.info("订单状态转换完成: orderCode={}, newStatus={}", 
                orderCode, 
                targetStatus.getName());
        
        // 可以在这里做一些后置处理
        // 例如：记录审计日志、发送监控指标等
    }
}
```

## 示例8：钱包支付（快速支付）

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class WalletPaymentService {
    
    private final PayMerchantOrderService orderService;
    private final PayUserWalletService walletService;
    private final PayOrderStateMachineService stateMachineService;
    
    /**
     * 钱包支付
     */
    @Transactional(rollbackFor = Exception.class)
    public ReturnResult<Void> payWithWallet(String orderCode) {
        // 1. 查询订单
        PayMerchantOrder order = orderService.getByCode(orderCode);
        if (order == null) {
            return ReturnResult.illegal("订单不存在");
        }
        
        // 2. 检查订单状态
        if (order.getPayMerchantOrderStatus() != PayOrderStatus.PAY_WAITING) {
            return ReturnResult.illegal("订单状态不正确");
        }
        
        // 3. 查询钱包余额
        PayUserWallet wallet = walletService.getByUserId(order.getUserId());
        if (wallet.getBalance().compareTo(order.getPayMerchantOrderAmount()) < 0) {
            return ReturnResult.illegal("钱包余额不足");
        }
        
        // 4. 扣减钱包余额
        boolean deducted = walletService.deduct(
                order.getUserId(),
                order.getPayMerchantOrderAmount()
        );
        
        if (!deducted) {
            return ReturnResult.error("扣减钱包余额失败");
        }
        
        // 5. 使用状态机转换状态：待支付 -> 支付成功
        boolean success = stateMachineService.sendEvent(
                orderCode,
                PayOrderStatus.PAY_WAITING,
                PayOrderEvent.PAY_SUCCESS,
                order
        );
        
        if (!success) {
            // 回滚钱包余额
            walletService.add(order.getUserId(), order.getPayMerchantOrderAmount());
            return ReturnResult.error("订单状态转换失败");
        }
        
        // 6. 更新订单状态
        order.setPayMerchantOrderStatus(PayOrderStatus.PAY_SUCCESS);
        order.setPayMerchantOrderPayTime(LocalDateTime.now());
        order.setPayMerchantOrderFinishedTime(LocalDateTime.now());
        orderService.finishWechatOrder(order);
        
        log.info("钱包支付成功: orderCode={}, amount={}", 
                orderCode, 
                order.getPayMerchantOrderAmount());
        
        return ReturnResult.ok();
    }
}
```

## 请求和响应对象示例

```java
@Data
public class CreateOrderRequest {
    /**
     * 支付金额
     */
    private BigDecimal amount;
    
    /**
     * 商品ID
     */
    private String productId;
    
    /**
     * 备注
     */
    private String remark;
}

@Data
public class RefundRequest {
    /**
     * 订单编号
     */
    private String orderCode;
    
    /**
     * 退款金额
     */
    private BigDecimal refundAmount;
    
    /**
     * 退款原因
     */
    private String refundReason;
}

@Data
public class OrderStatusResponse {
    /**
     * 订单编号
     */
    private String orderCode;
    
    /**
     * 订单状态
     */
    private PayOrderStatus status;
    
    /**
     * 状态名称
     */
    private String statusName;
}

@Data
public class OrderQueryRequest {
    /**
     * 页码
     */
    private Integer pageNum = 1;
    
    /**
     * 页大小
     */
    private Integer pageSize = 10;
    
    /**
     * 开始时间
     */
    private LocalDateTime startTime;
    
    /**
     * 结束时间
     */
    private LocalDateTime endTime;
}
```

## 总结

以上示例展示了支付模块的常见使用场景：

1. ✅ 创建订单和支付
2. ✅ 处理支付回调
3. ✅ 订单退款
4. ✅ 订单状态查询和关闭
5. ✅ 监听订单事件
6. ✅ 定时任务处理超时订单
7. ✅ 自定义状态转换拦截器
8. ✅ 钱包支付（快速支付）

所有示例都充分利用了状态机的特性，确保订单状态流转的合法性和可追溯性。

