# 支付状态机模块优化说明

## 优化概览

本次优化主要解决以下问题：
1. ✅ 支持多种状态机持久化策略（数据库、数据库+Redis）
2. ✅ 使用 SPI 方式实现可插拔的持久化方案
3. ✅ 在状态机中统一处理订单状态更新和流水保存
4. ✅ 修复 `finishWechatOrder` 方法被退款回调错误调用的问题
5. ✅ 整体架构优化和代码重构

## 核心变更

### 1. 配置属性类 (PayProperties)

**文件**: `PayProperties.java`

新增支付配置属性，支持以下配置：

```yaml
plugin:
  pay:
    # 状态机持久化类型：DATABASE（仅数据库）或 DATABASE_REDIS（数据库+Redis）
    state-machine-persist-type: DATABASE_REDIS
    # Redis 缓存过期时间（秒），默认 30 分钟
    redis-cache-expire-seconds: 1800
    # 状态机超时时间（毫秒），默认 5 秒
    state-machine-timeout-millis: 5000
    # 是否启用状态机日志
    enable-state-machine-log: true
    # 订单超时时间（分钟），默认 30 分钟
    order-timeout-minutes: 30
```

### 2. 状态机持久化 SPI

**接口**: `PayOrderStateMachinePersister.java`

定义统一的持久化接口，支持：
- `persist()` - 保存状态机状态
- `restore()` - 恢复状态机状态
- `delete()` - 删除状态机状态
- `getType()` - 获取持久化类型

**实现类**:

1. **DatabaseStateMachinePersister** - 仅数据库持久化
   - 直接使用数据库存储状态
   - 适用于对性能要求不高的场景
   - 配置：`state-machine-persist-type: DATABASE`

2. **DatabaseRedisStateMachinePersister** - 数据库 + Redis 缓存
   - Redis 作为一级缓存，数据库作为持久化存储
   - 读取优先从 Redis 获取，写入同时更新 Redis 和数据库
   - 适用于高并发场景
   - 配置：`state-machine-persist-type: DATABASE_REDIS`

### 3. 统一的状态转换处理器

**文件**: `PayOrderTransitionAction.java`

在状态机 Action 中统一处理：

#### 3.1 订单状态更新
根据不同的事件自动更新相应字段：
- `PAY_SUCCESS` - 更新支付时间、交易号
- `REFUND_SUCCESS` / `REFUND_PART_SUCCESS` - 更新退款编号、退款原因、退款账户、退款时间
- `TIMEOUT` / `CANCEL` / `CLOSE` - 更新完成时间
- `CREATE_FAILED` - 记录失败原因

#### 3.2 订单流水保存
每次状态转换自动保存流水记录，包含：
- 流水编号（自动生成）
- 订单编号
- 订单状态

#### 3.3 业务时间字段更新
自动更新相关的时间字段，无需手动设置。

### 4. 优化后的服务方法

#### 4.1 finishWechatOrder（支付成功）

**优化前**:
```java
payMerchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_SUCCESS);
payMerchantOrder.setPayMerchantOrderPayTime(LocalDateTime.now());
payMerchantOrder.setPayMerchantOrderFinishedTime(LocalDateTime.now());
this.updateById(payMerchantOrder);

// 保存流水
PayMerchantOrderWater water = new PayMerchantOrderWater();
water.setPayMerchantOrderCode(orderCode);
water.setPayMerchantOrderStatus(PayOrderStatus.PAY_SUCCESS);
payMerchantOrderWaterService.save(water);
```

**优化后**:
```java
// 状态机自动处理所有更新和流水保存
boolean success = stateMachineService.sendEvent(
    orderCode,
    currentStatus,
    PayOrderEvent.PAY_SUCCESS,
    payMerchantOrder
);
```

#### 4.2 refundOrder（退款）

**优化前**:
```java
payMerchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_REFUND_SUCCESS);
payMerchantOrder.setPayMerchantOrderRefundCreateTime(LocalDateTime.now());
this.updateById(payMerchantOrder);

// 保存流水
PayMerchantOrderWater water = new PayMerchantOrderWater();
water.setPayMerchantOrderCode(orderCode);
water.setPayMerchantOrderStatus(PayOrderStatus.PAY_REFUND_SUCCESS);
payMerchantOrderWaterService.save(water);
```

**优化后**:
```java
// 状态机根据目标状态自动选择事件并处理
boolean success = stateMachineService.sendEvent(
    orderCode,
    currentStatus,
    event,  // REFUND_SUCCESS 或 REFUND_PART_SUCCESS
    payMerchantOrder
);
```

### 5. 修复退款回调问题

**问题**: 在 `WebchatCallbackRefundNotificationParser` 中，退款回调错误地调用了 `finishWechatOrder` 方法，该方法内部发送的是 `PAY_SUCCESS` 事件，导致退款时状态转换错误。

**修复**:
```java
// 修复前（错误）
merchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_REFUND_SUCCESS);
payMerchantOrderService.finishWechatOrder(merchantOrder);  // ❌ 错误！

// 修复后（正确）
merchantOrder.setPayMerchantOrderRefundCode(refund.getRefundId());
merchantOrder.setPayMerchantOrderRefundUserReceivedAccount(refund.getUserReceivedAccount());
merchantOrder.setPayMerchantOrderStatus(PayOrderStatus.PAY_REFUND_SUCCESS);
payMerchantOrderService.refundOrder(merchantOrder);  // ✅ 正确！
```

## 优化效果

### 1. 代码简化
- 去除重复的订单状态更新代码
- 去除重复的流水保存代码
- 统一的状态转换逻辑

### 2. 可维护性提升
- 状态转换逻辑集中在 Action 中，易于维护
- 新增状态只需在 Action 中添加处理逻辑
- SPI 方式便于扩展新的持久化策略

### 3. 性能优化
- 支持 Redis 缓存，减少数据库访问
- 缓存过期时间可配置
- 适应高并发场景

### 4. 错误修复
- 修复退款回调调用错误方法的问题
- 确保状态转换的正确性

## 使用示例

### 1. 配置持久化策略

**application.yml**:
```yaml
plugin:
  pay:
    # 使用数据库+Redis持久化
    state-machine-persist-type: DATABASE_REDIS
    redis-cache-expire-seconds: 1800
    enable-state-machine-log: true
```

### 2. 支付成功处理

```java
@Service
public class PaymentService {
    
    @Autowired
    private PayOrderStateMachineService stateMachineService;
    
    public void handlePaymentSuccess(String orderCode, String transactionId) {
        // 查询订单
        PayMerchantOrder order = orderService.getByCode(orderCode);
        
        // 设置交易号
        order.setPayMerchantOrderTransactionId(transactionId);
        
        // 发送支付成功事件
        // 状态机会自动：
        // 1. 更新订单状态为 PAY_SUCCESS
        // 2. 更新支付时间
        // 3. 保存订单流水
        // 4. 持久化状态机状态
        boolean success = stateMachineService.sendEvent(
            orderCode,
            order.getPayMerchantOrderStatus(),
            PayOrderEvent.PAY_SUCCESS,
            order
        );
        
        if (success) {
            log.info("支付成功处理完成: {}", orderCode);
        }
    }
}
```

### 3. 退款处理

```java
@Service
public class RefundService {
    
    @Autowired
    private PayOrderStateMachineService stateMachineService;
    
    public void handleRefund(String orderCode, String refundId, String reason) {
        // 查询订单
        PayMerchantOrder order = orderService.getByCode(orderCode);
        
        // 设置退款信息
        order.setPayMerchantOrderRefundCode(refundId);
        order.setPayMerchantOrderRefundReason(reason);
        
        // 发送退款成功事件
        // 状态机会自动：
        // 1. 更新订单状态为 PAY_REFUND_SUCCESS
        // 2. 更新退款时间
        // 3. 保存订单流水
        // 4. 持久化状态机状态
        boolean success = stateMachineService.sendEvent(
            orderCode,
            order.getPayMerchantOrderStatus(),
            PayOrderEvent.REFUND_SUCCESS,
            order
        );
        
        if (success) {
            log.info("退款处理完成: {}", orderCode);
        }
    }
}
```

## 注意事项

1. **配置 Redis**：如果使用 `DATABASE_REDIS` 模式，需要确保 Redis 已正确配置。

2. **缓存一致性**：Redis 缓存有过期时间，过期后会从数据库重新加载。

3. **事务处理**：状态机操作在事务内执行，确保数据一致性。

4. **日志监控**：建议在生产环境开启状态机日志，便于问题排查。

5. **性能调优**：根据实际业务量调整 Redis 缓存过期时间和状态机超时时间。

## 后续改进建议

1. 增加状态机事件的审计日志
2. 支持状态机状态的批量操作
3. 增加状态转换的权限控制
4. 提供状态机流程的可视化界面

## 总结

本次优化通过引入 SPI 持久化方案、统一的 Action 处理器，大幅简化了代码，提升了可维护性和性能。同时修复了退款回调的关键问题，确保了系统的正确性。

